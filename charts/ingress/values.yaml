host: onmshs.local
port: 443 #set depending on tls.enabled and the ingress ports, do not change
protocol: https #set depending on tls.enabled, do not change
global:
 imagePullPolicy: IfNotPresent
 privateRepoEnabled: false

openShift:
 route: false

openNMS:
  global:
    image:
      repository: opennms
      tag: latest
    springBoot:
      env: {}
    kafkaClient:
      bootstrapServers: onms-kafka.lokahi.svc.cluster.local:9092
    enableJsonLogging: false
    openTelemetry:
      otlpTracesEndpoint: null
      env:
        OTEL_PROPAGATORS: tracecontext,baggage,jaeger

  api:
    path: /api
    serviceName: opennms-rest-server

  ui:
    path: /
    serviceName: opennms-ui
    tlsSecretName: opennms-ui-certificate
    port: 8080
    ingressAnnotations:
      nginx.ingress.kubernetes.io/configuration-snippet: |
        add_header X-Content-Type-Options "nosniff";
        add_header X-Frame-Options "sameorigin";
        add_header server_tokens "off";
      nginx.ingress.kubernetes.io/client-body-buffer-size: 4k
      nginx.ingress.kubernetes.io/client-header-buffer-size: 4k
      nginx.ingress.kubernetes.io/large-client-header-buffers: 4 16k
      nginx.ingress.kubernetes.io/proxy-body-size: 4m
      nginx.ingress.kubernetes.io/proxy-buffer-size: 6k
  
  minionGateway:
    serviceName: opennms-minion-gateway
    tlsSecretName: opennms-minion-gateway-certificate
    imageShortName: lokahi-minion-gateway
    internalGrpcPort: 8991
    ingressAnnotations:
      nginx.ingress.kubernetes.io/proxy-body-size: "0" # To avoid HTTP 413 and "client intended to send too large chunked body: X bytes while sending request to upstream"
      nginx.ingress.kubernetes.io/auth-tls-secret: default/client-root-ca-certificate
      nginx.ingress.kubernetes.io/auth-tls-verify-client: "on"
      nginx.ingress.kubernetes.io/auth-tls-verify-depth: "1"
      nginx.ingress.kubernetes.io/auth-url: "http://opennms-minion-certificate-verifier.default.svc.cluster.local:8080/certificate/debug"
      nginx.ingress.kubernetes.io/auth-response-headers: "tenant-id, location-id"
      nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream: true
      nginx.ingress.kubernetes.io/server-snippet: |
        grpc_read_timeout "1200s";
        grpc_send_timeout "1200s";
        client_body_timeout "1200s";

keycloak:
  path: /auth
  port: 8080
  serviceName: onms-keycloak

grafana:
  path: /grafana
  port: 3000
  serviceName: grafana

nodeRestrictions: # will be applied to every pod in the instance
  enabled: false
  key: kubernetes.azure.com/scalesetpriority
  Value: spot

tls:
  enabled: true
  # When Certificate Generation option is set to false you need to manually prepare secrets which are referred by
  # this helm chart. This includes creation of tls certificates for ingress but also for mutual tls between minions and
  # minion-gateway service
  CertificateGeneration: false

ingress:
  enabled: true
  defaultEndpointsEnabled: true
  httpPort: 80
  httpsPort: 443
  controllerImage: registry.k8s.io/ingress-nginx/controller:v1.7.0@sha256:7612338342a1e7b8090bef78f2a04fffcadd548ccaabe8a47bf7758ff549a5f7
  secretJobImage: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v1.1.1@sha256:64d8c73dca984af206adf9d6d7e46aa550362b1d7a01f3a0a91b20cc67868660
  webhookPatchJobImage: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v1.1.1@sha256:64d8c73dca984af206adf9d6d7e46aa550362b1d7a01f3a0a91b20cc67868660

customErrors:
  image: quay.io/kubernetes-ingress-controller/custom-error-pages:0.4
  debug: true

prometheus:
  enabled: true
  path: /prometheus
  serviceName: prometheus
  port: 9090
