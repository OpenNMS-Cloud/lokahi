/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2019 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

package org.opennms.horizon.alertservice.drools;

import java.util.Date;
import java.util.List;
import org.kie.api.time.SessionClock;
import org.opennms.horizon.alertservice.db.entity.AlertAssociation;
import org.opennms.horizon.alertservice.db.entity.Alert;
import org.opennms.horizon.alertservice.model.AlertSeverity;
import java.util.LinkedList
import org.opennms.horizon.alertservice.db.entity.Alert;

global org.opennms.horizon.alertservice.api.AlertService alertService;

declare org.opennms.horizon.alertservice.db.entity.Alert
    @role(event)
    @timestamp(lastUpdateTime)
end

rule "setSituationSeverityToMaxAlertSeverity"
  when
    $sessionClock : SessionClock()
    $situation : Alert( isSituation() == true, $relatedAlertIds : relatedAlertIds )
    $relatedAlerts : LinkedList() from collect( Alert($relatedAlertIds contains alertId) )
    $maxSeverity : AlertSeverity( isLessThanOrEqual(AlertSeverity.NORMAL) ) from accumulate( Alert( $severity : severity ) from $relatedAlerts, maxSeverity( $severity ) )
    Alert( this == $situation, severity != $maxSeverity )
  then
    alertService.setSeverity($situation, $maxSeverity, new Date($sessionClock.getCurrentTime()));
end

rule "escalateSituationSeverity"
  when
    $sessionClock : SessionClock()
    $situation : Alert( isSituation() == true, $relatedAlertIds : relatedAlertIds )
    $relatedAlerts : LinkedList() from collect( Alert($relatedAlertIds contains alertId) )
    $maxSeverity : AlertSeverity( isGreaterThan(AlertSeverity.NORMAL) ) from accumulate( Alert( $severity : severity ) from $relatedAlerts, maxSeverity( $severity ) )
    Alert( this == $situation, severity != AlertSeverity.escalate($maxSeverity) )
  then
    alertService.setSeverity($situation, AlertSeverity.escalate($maxSeverity), new Date($sessionClock.getCurrentTime()));
end

rule "SituationHasBeenAcknowledged"
  when
    $sessionClock : SessionClock()
    // The Situation has been Acknowledged.
    $situation : Alert( isSituation() == true, $relatedAlertIds : relatedAlertIds, isAcknowledged() == true )
    // There is an ACKNOWLEDGE ack in working memory.
//    $situationAck : OnmsAcknowledgment( refId == $situation.id, ackAction == AckAction.ACKNOWLEDGE)
    // There are NO alert ACKs after the Situation ACK.
//    $relatedAlertAcks : LinkedList( size == 0 ) from collect (OnmsAcknowledgment($relatedAlertIds contains refId, ackTime > $situationAck.getAckTime() ) )
    // There is at least one related alert that is not acknowledged and it was correlated before the Situation ACK.
    $relatedAlerts : LinkedList( size > 0 ) from collect( Alert($relatedAlertIds contains alertId, isAcknowledged() == false ) )
    // There is a related alert that is unacknowleged
    $relatedAlert : Alert($relatedAlertIds contains alertId, $unAkedAlertId : alertId, isAcknowledged() == false )
    // The UN-ACK time for that alert is prior to the Situation ACK
//    $unAcknowledgment : OnmsAcknowledgment(refId == $unAkedAlertId, ackAction == AckAction.UNACKNOWLEDGE, ackTime < $situationAck.getAckTime() )
    // The association time of that alert is before the ACK time on the situation
//    $unAkedRelatedAlertAssociation : AlertAssociation(getSituationAlertId == $situation, $unAcknowledgment.refId == relatedAlert.getAlertId(), mappedTime < $situationAck.getAckTime() )
  then
    Date acknowledgeTime = new Date($sessionClock.getCurrentTime());
    // Acknowledge all of the alerts in one go or we will trigger more rule evaluations
//    for (int i=0; i < $relatedAlerts.size(); i++) {
//       alertService.acknowledgeAlert((Alert)$relatedAlerts.get(i), acknowledgeTime, "drools");
//    }
end

rule "SituationHasBeenUnAcknowledged"
  when
    $sessionClock : SessionClock()
    // The Situation has been Unacknowledged (or was never Acknowledged)
    $situation : Alert( isSituation() == true, $relatedAlertIds : relatedAlertIds, isAcknowledged() == false )
    // Un-Ack'd and Non-Ack'd Alerts will have an UNACKNOWLEDGE ack in working memory.
//    $situationAck : OnmsAcknowledgment( refId == $situation.alertId, ackAction == AckAction.UNACKNOWLEDGE)
    // There are NO alert ACKs after the Situation ACK
//    $relatedAlertAcks : LinkedList( size == 0 ) from collect (OnmsAcknowledgment($relatedAlertIds contains refId, ackAction == AckAction.ACKNOWLEDGE, ackTime > $situationAck.getAckTime() ) )
    // There is NO NAK on any of the Related Alerts BEFORE the Situation NAK - it would have triggered the Situation NAK and should not be propagated.
//    $triggeringNaks : LinkedList( size == 0 ) from collect (OnmsAcknowledgment($relatedAlertIds contains refId, ackAction == AckAction.UNACKNOWLEDGE, ackTime < $situationAck.getAckTime() ) )
    // The list of Alerts to Un-Acknowledge
    $relatedAlerts : LinkedList( size > 0 ) from collect (Alert($relatedAlertIds contains alertId, isAcknowledged() == true) )
  then
    Date acknowledgeTime = new Date($sessionClock.getCurrentTime());
//    for (int i=0; i < $relatedAlerts.size(); i++) {
//        alertService.unacknowledgeAlert((Alert)$relatedAlerts.get(i), acknowledgeTime);
//    }
end

rule "AllRelatedAlertsAcknowledged"
  when
    $sessionClock : SessionClock()
    // The Situation has been Unacknowledged (or was never Acknowledged)
    $situation : Alert( isSituation() == true, $relatedAlertIds : relatedAlertIds, isAcknowledged() == false )
    // Un-Ack'd and Non-Ack'd Alerts will have an UNACKNOWLEDGE ack in working memory.
//    $situationAck : OnmsAcknowledgment( refId == $situation.id, ackAction == AckAction.UNACKNOWLEDGE)
    // All the relatedAlerts are Acknowledged.
//    List(size == $relatedAlertIds.size) from collect (OnmsAcknowledgment($relatedAlertIds contains refId, ackAction == AckAction.ACKNOWLEDGE ) )
    // There is at least one alert ACK after the Situation ACK.
//    $triggeringAlertAcks : LinkedList( size > 0 ) from collect (OnmsAcknowledgment($relatedAlertIds contains refId, ackAction == AckAction.ACKNOWLEDGE, ackTime > $situationAck.getAckTime() ) )
  then
   	alertService.acknowledgeAlert((Alert)$situation, new Date($sessionClock.getCurrentTime()), "drools");
end

rule "newAlertsUnAcknowledgesSituation"
  when
    $sessionClock : SessionClock()
    // There is an Acknowledged Situation.
    $situation : Alert( isSituation() == true, $relatedAlertIds : relatedAlertIds, isAcknowledged() == true )
    // The Situation Acknowledgment is in Working Memory.
//    $situationAck : OnmsAcknowledgment( refId == $situation.id, ackAction == AckAction.ACKNOWLEDGE )
    // There is at least one un-Acknowledgment for one of the related alerts with a time after the Situation was acknowledged.
//    $unAkedRelatedAlerts : LinkedList(size > 0) from collect (OnmsAcknowledgment($relatedAlertIds contains refId, ackAction == AckAction.UNACKNOWLEDGE, ackTime > $situationAck.getAckTime() ) )
  then
   	alertService.unAcknowledgeAlert($situation, new Date($sessionClock.getCurrentTime()));
end

rule "oldAlertsUnAcknowledgesSituation"
  when
    $sessionClock : SessionClock()
    // There is an Acknowledged Situation.
    $situation : Alert( isSituation() == true, $relatedAlertIds : relatedAlertIds, isAcknowledged() == true )
    // The Situation Acknowledgment is in Working Memory.
//    $situationAck : OnmsAcknowledgment( refId == $situation.id, ackAction == AckAction.ACKNOWLEDGE )
    // There is a related alert that is unacknowleged
    // The UN-ACK time for that alert is prior to the Situation ACK
//    $unAcknowledgment : OnmsAcknowledgment($relatedAlertIds contains refId, $unAkedAlertId : refId, ackAction == AckAction.UNACKNOWLEDGE, ackTime < $situationAck.getAckTime() )
    // The association time of that alert is later than the ACK time on the situation
//	$unAkedRelatedAlertAssociation : AlertAssociation(situationAlert == $situation, $unAcknowledgment.refId == relatedAlert.getId(), mappedTime > $situationAck.getAckTime() )
  then
   	alertService.unAcknowledgeAlert($situation, new Date($sessionClock.getCurrentTime()));
end
