host: onmshs
port: 443 #set depending on tls.enabled and the Ingress ports, do not change
global:
 image:
  repository: opennms
  tag: latest
 imagePullPolicy: IfNotPresent
 privateRepoEnabled: false
 springBoot:
  env: {}
 kafkaClient:
  bootstrapServers: onms-kafka:9092
 enableJsonLogging: false
 openTelemetry:
  otlpTracesEndpoint: null
  env:
   OTEL_PROPAGATORS: tracecontext,baggage,jaeger

openNMS:
  minion:
    enabled: false
    serviceName: opennms-minion
    imageShortName: lokahi-minion
    replicas: 1
    port: 8181
    sshPort: 8101
    trapsListenerPort: 1162
    netflow5ListenerPort: 8877
    netflow9ListenerPort: 4729
    netflowListenerPort: 9999
    resources:
      limits:
        cpu: "2"
        memory: 4Gi
      requests:
        cpu: "1"
        memory: 2Gi
    extraVolumes: []
    extraMounts: []
    extraInitContainers: []
    addDefaultLocation: false
  minionGateway:
    serviceName: opennms-minion-gateway
    tlsSecretName: opennms-minion-gateway-certificate
    imageShortName: lokahi-minion-gateway
    InternalGrpcPort: 8991
    replicas: 1
    UseKubernetes: "true"
    DbName: "desenv"
    DbSchemaName: "minion_gateway"
    DbHost: "postgres"
    resources:
      limits:
        cpu: "2"
        memory: 4Gi # MaxRAMPercentage=40 for heap (avg-usage=480MB) plus up to 2GB off-heap (4 Ignite Data Regions)
      requests:
        cpu: "1"
        memory: 2Gi
    IngressAnnotations:
      nginx.ingress.kubernetes.io/proxy-body-size: "0" # To avoid HTTP 413 and "client intended to send too large chunked body: X bytes while sending request to upstream"
      nginx.ingress.kubernetes.io/auth-tls-secret: default/client-root-ca-certificate
      nginx.ingress.kubernetes.io/auth-tls-verify-client: "on"
      nginx.ingress.kubernetes.io/auth-tls-verify-depth: "1"
      nginx.ingress.kubernetes.io/auth-url: "http://opennms-minion-certificate-verifier.default.svc.cluster.local:8080/certificate/debug"
      nginx.ingress.kubernetes.io/auth-response-headers: "tenant-id, location-id"
      nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream: true
      nginx.ingress.kubernetes.io/server-snippet: |
        grpc_read_timeout "1200s";
        grpc_send_timeout "1200s";
        client_body_timeout "1200s";
    kafkaSecretName: ~
  MinionCertificateManager:
    enabled: false
    serviceName: opennms-minion-certificate-manager
    CaSecretName: ""
    MtlsSecretName: opennms-minion-certificate
    imageShortName: lokahi-minion-certificate-manager
    replicas: 1
    VolumeSize: 1Gi
    resources:
      limits:
        cpu: "1"
        memory: 1Gi
      requests:
        cpu: "1"
        memory: 1Gi
  MinionCertificateVerifier:
    serviceName: opennms-minion-certificate-verifier
    imageShortName: lokahi-minion-certificate-verifier
    replicas: 1
    resources:
      limits:
        cpu: "1"
        memory: 1Gi # MaxRAMPercentage=50,avg-usage=245MB
      requests:
        cpu: "1"
        memory: 1Gi
    CertificateManagerUrl: ""
keycloak:
  Path: /auth
  imageShortName: lokahi-keycloak
  port: 8080
  HttpsPort: 8443
  HostnamePort: ~
  hostnameAdminUrl: ~
  replicas: 1
  serviceName: onms-keycloak
  tlsSecretName:
  DbSchemaName: "keycloak"
  DbName: "desenv"
  DbHost: "postgres"
  resources:
    limits:
      cpu: "1"
      memory: 2Gi
    requests:
      cpu: "1"
      memory: 1Gi
  AdminUsername: admin
  adminPassword: notset
  realmName: opennms
  DynamicRealmConfig: true
  ConfigmapName: keycloak-realm-configmap
  Environment: {}

nodeRestrictions: # will be applied to every pod in the instance
  enabled: false
  key: kubernetes.azure.com/scalesetpriority
  value: spot
tls:
  enabled: true
  # When Certificate Generation option is set to false you need to manually prepare secrets which are referred by
  # this helm chart. This includes creation of tls certificates for ingress but also for mutual tls between minions and
  # minion-gateway service
  CertificateGeneration: false
