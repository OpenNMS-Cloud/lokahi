/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2009-2022 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2022 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0.3-b01-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2009.01.29 at 01:15:48 PM EST 
//

package org.opennms.netmgt.provision.persistence.dto;

import java.net.InetAddress;
import java.util.HashMap;
//import javax.xml.bind.ValidationException;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.validation.ValidationException;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.opennms.horizon.core.lib.IPAddress;
import org.opennms.horizon.core.lib.InetAddressUtils;
import org.opennms.horizon.db.model.PrimaryType;


/**
 * <p>RequisitionInterface class.</p>
 */
@Data
@Slf4j
public class RequisitionInterfaceDTO extends CategoriesAndMetadataDTO {

    private Map<String, RequisitionMonitoredServiceDTO> monitoredServices = new HashMap<>();
    private String description;
    //TODO: why an object?
    private Boolean managed;
    
    // annotated on the class, for some compatibility/initialization
    //TODO: this may cause a circular ref?
    private PrimaryType snmpPrimary;
    private Integer status;
    private InetAddress ipAddress;

    /**
     * <p>getMonitoredService</p>
     *
     * @param serviceName a {@link String} object.
     * @return a {@link RequisitionMonitoredServiceDTO} object.
     */
    public RequisitionMonitoredServiceDTO getMonitoredService(String serviceName) {
        return monitoredServices.get(serviceName);
    }

    /**
     * <p>deleteMonitoredService</p>
     *
     * @param service a {@link RequisitionMonitoredServiceDTO} object.
     */
    public void deleteMonitoredService(RequisitionMonitoredServiceDTO service) {
        deleteMonitoredService(service.getServiceName());
    }

    /**
     * <p>deleteMonitoredService</p>
     *
     * @param serviceName a {@link String} object.
     */
    public void deleteMonitoredService(String serviceName) {
        monitoredServices.remove(serviceName);
    }

    /**
     * <p>putMonitoredService</p>
     *
     * @param service a {@link RequisitionMonitoredServiceDTO} object.
     */
    public void putMonitoredService(RequisitionMonitoredServiceDTO service) {
        monitoredServices.put(service.getServiceName(), service);
    }

    /**
     * <p>setIpAddr</p>
     *
     * @param value a {@link String} object.
     */
    public void setIpAddr(String value) {
        try {
            ipAddress = InetAddressUtils.getInetAddress(value);
        } catch (Throwable e) {
            throw new IllegalArgumentException(String.format("Invalid IP address specified: %s", value), e);
        }
    }

    /**
     * <p>isManaged</p>
     *
     * @return a boolean.
     */
    public boolean isManaged() {
        if (managed == null) {
            return true;
        } else {
            return managed;
        }
    }

    /**
     * <p>setSnmpPrimary</p>
     *
     * @param value a {@link String} object.
     */
    public void setSnmpPrimary(final PrimaryType value) {
        if (value != null) {
            snmpPrimary = value;
        }
        else {
            snmpPrimary = PrimaryType.NOT_ELIGIBLE;
        }
    }

    public void setStatus(Integer value) {
        if (value == null) {
            status = 1;
        }
        else {
            status = value;
        }
    }

    //TODO: fix
    public void validate(RequisitionNodeDTO node) throws ValidationException {
        //TODO: this already handled by setter, but make sure this approach will work sith json unmarshalling. Ie, do
        // we need to allow only the String version to be specified? If so, rollback the consolidation here
//        if (ipAddress != null) {
//            try {
//                ipAddress = new IPAddress(ipAddressStr).toInetAddress();
//            } catch (IllegalArgumentException iae) {
//                log.warn(String.format("Invalid IP address %s", ipAddressStr));
//                throw new IPValidationException(String.format("Invalid IP address %s", ipAddressStr), iae);
//            }
//        }

        if (monitoredServices != null) {
            Set<String> serviceNameSet = new HashSet<>();
            for (final RequisitionMonitoredServiceDTO svc : monitoredServices.values()) {
                svc.validate();
                if (!serviceNameSet.add(svc.getServiceName())) {
                    throw new ValidationException(String.format("Duplicate service name: %s", svc.getServiceName()));
                }
            }
        }

        // there can be only one primary interface per node
        if (snmpPrimary == PrimaryType.PRIMARY) {
            long otherPrimaryInterfaces = node.getInterfaces().values().stream()
                    .filter(iface -> PrimaryType.PRIMARY == iface.getSnmpPrimary())
                    .filter(iface -> !iface.getIpAddress().equals(this.getIpAddress()))
                    .count();
            if (otherPrimaryInterfaces > 0) {
                throw new ValidationException("Node foreign ID (" + node.getForeignId() + ") contains multiple primary interfaces. Maximum one is allowed.");
            }
        }
    }
}
